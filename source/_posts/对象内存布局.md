---
title: 对象内存布局
date: 2020-06-02 17:11:27
tags:
- java
- jvm
---

# 对象内存布局详解

ps:使用JOL插件能查看打印对象的内存布局情况
```
Object o = new Object();
```
创建一个新对象的内存布局。
在一个64位系统中，一般安装的JVM也是64位，其指针也是64位的即8字节，但是一般开启了类型指针压缩，为4字节。
```
-XX:UseCompressedClassPointers //开启类型指针压缩
-XX:UseCompressedOops //开启普通指针压缩，对于堆内存低于4G会强制使用压缩指针，堆内存高于32G会强制使用8字节指针
```

一个Object对象包括8个字节的markword、被压缩过的类型指针ClassPointer 4个字节。两部分合起来12字节为对象头。
但是Object对象没有成员对象，大小为0，对象大小要8个字节对齐，为了提高cpu访问内存的效率，cpu访问内存数据是直接读取8个字节，如果跨段放不对齐就很有可能需要读取两次。

那么最后会补齐4个字节，一个Object对象的大小是16字节。如果没有开启类型指针压缩，一个Object对象仍然是16字节，因为不需要填充字节。

为什么要对齐，cpu读取内存，按照总线带宽一次读取64位。

## 8字节的markword

关于synchronized对象锁的信息、与GC的信息记录在markword里面，根据锁的类型markword占用8个字节的方式也不一样。


|锁状态|25位|31位|1位|4bit|1bit偏向锁位|2bit锁标志位|
|:-|:-:|:-:|:-:|:-:|:-:|-:|
|无锁态(new)|unused|identity hashCode（调用了hashCode方法会存进来）|unused|分代年龄|0|01|

|锁状态|54位|2位|1位|4bit|1bit偏向锁位|2bit锁标志位|
|:-|:-:|:-:|:-:|:-:|:-:|-:|
|偏向锁|当前线程指针JavaThread*|Epoch|unused|分代年龄|1|01|

|锁状态|62位|2bit锁标志位|
|:-|:-:|-:|
|轻量级锁\自选锁\无锁 |指向线程栈中LockRecord的指针|00|
|重量级锁 |指向互斥量（重量级锁）的指针|10|
|GC标记信息 |CMS过程用到的标记信息|11|


### 锁升级过程
当第一次加锁时候，这个时候加的就是偏向锁，这个偏向锁就是在markWord里面java线程指针指向当前线程。

当第一个线程执行期间，这时候又一条线程来获取锁，这时候会存在一个锁竞争，这时候撤销老线程的偏向锁（**怎么撤销呢？新线程通知老线程stop the world**），

两条线程（先在线程堆栈里开一个锁记录的空间，把锁对象markword的拷贝进来）采用自旋的方式（拿着锁对象的markword去cas，markword没改就把锁对象的前62位设置为当前线程锁记录的指针）将自己线程栈的锁记录的指针放到锁的markWord中，谁写成功了谁就获得这个轻量级锁（获得轻量级锁以后将锁记录的Owner指针指向锁对象的markword），这个轻量级锁是位于用户态的，申请下来也很快不占资源，但是自旋是消耗cpu的，如果太多线程长时间自旋，cpu很容易也就占满了，因此必须升级的。（自旋是什么意思呢，就是不停读锁的markWord出来，看是不是可以修改了，如果可以就将自己的锁记录的指针贴到markWord里面，如果不可以循环自旋）   

最后轻量级锁重入的实现:  首先构建一个无锁状态的displace markword（如果已经是轻量级锁的话，猜想根据markword的指针读对应锁记录出来，最后两位拼接01），然后CAS失败，说明不是无锁了，然后判断是不是锁重入（估计是读上一个锁记录的Owner指针指的是不是这个锁对象），如果是的，就将最新的锁记录的displace markword置null，然后这个锁记录的Owner也指向锁对象的markword，重入的时候建的锁记录的displace markword是null，只有第一次不为null  

轻量级锁解锁:  cas替换displace markword到锁对象markword成功则解锁成功（如果displace markword为null什么也不做，说明重入了），如果失败则膨胀成重量级锁以后再解锁。【BUT为什么会解锁失败？】


如果一个线程占着这个锁太久了，另一条线程疯狂自旋也拿不到锁，jvm会有个自适应自旋Adaptive Self Spinning的过程，当自选次数达到多少次了，就要升级到重量级锁。


膨胀为重量级锁时，如果是另一个线程B自旋太多次导致的，另一个线程B直接阻塞，因为轻量级锁这个线程A还在用cpu呢，那么这时候锁对象头被改了，markword存的是指向mutex的指针，锁标志位也变成10了，这时候A线程指向结束了，想解锁轻量级锁发现解锁失败了，说明已经是重量级锁了吧，先获得重量级锁，再解锁。让出资源。

#### ps:重量级锁是什么
首先明确用户态与内核态，某些系统调用的操作，只能在内核态调用。那么这里的重量级锁就必须在内核态分配一个mutex结构（操作系统的互斥量）给某个线程，然后java里这个锁的markWord填的就是指向这个mutex的指针。

#### 升级为重量级锁以后有什么好处呢？
获得的重量级锁对象以后，当前线程会占用cpu继续执行，而其他争夺锁的线程不再自旋消耗cpu资源而是进入到一个锁竞争队列，并且进入阻塞态。

### 锁消除
就是JIT编译的时候，去除不可能存在共享资源竞争的锁，什么意思呢？就是这个资源只能被某一个线程访问，不存在锁竞争但是代码里面是加了锁的。这时候呢去除这个锁避免加锁消耗资源。

以马士兵老师举例说明一下
```java
public void add(String s1,String s2){
    StringBuffer sb = new StringBuffer();
    sb.append(si).append(s2);
}
```
上面这个例子中，StringBuffer的append方法是加了synchronized修饰的，但是这个sb只能在这个方法中使用，是一个局部变量引用，只能被单一线程占用，因此会消除sb内部的加锁操作。

ps:在看视频的时候老师讲到了逃逸分析：是指我new出一个对象来，在内存分配过程中，发现这个对象只是在这个方法里使用，这个对象内存直接分配在栈上。

### 锁粗化

就是将加锁的范围扩大，还是以马士兵老师的例子为例：
```java
public String test(String str){
    int i=0;
    StringBuffer sb = new StringBuffer();
    while(i<100){
        sb.append(str);
        i++;
    }
    return sb.toString();
}

```
这里jvm针对100次循环的加锁操作，将加锁的范围扩大到了循环外加一次锁即可。