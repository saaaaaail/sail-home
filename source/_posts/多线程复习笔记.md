---
title: 多线程复习笔记
date: 2020-07-01 22:27:33
tags:
- java
- 多线程
---
# sail的多线程复习笔记

## 线程
1. 线程启动 run()、start()
   ```
    这俩方法的区别、原理？
   ```
2. sleep() 
3. yield() 
   ```
    让出一下cpu，但是调度由操作系统去做，不一定切换线程，可能调度回来还是原线程，也可能切换
   ```
4. join() 
   ```
    经常用来等待另一个线程的结束。比如t1、t2两个线程，在t1的代码中调t2.join()表示这时候转到t2去执行，t2执行完了继续执行t1。

    保证三个线程顺序执行？
    1. 主线程依次t1.join()、t2.join()、t3.join()
    2. 主线程t1.join(),t1线程中调t2.join(),t2线程中调t3.join()
   ```
5. interrupt()
    ```
    设置一个中断的标志位，当线程正在运行则不受影响，直到线程被join、wait、sleep等方法打断，会马上抛出InterruptException异常，我们捕获这个异常来处理，如果直接抛出，线程就会结束，如果不抛，而是人为处理掉，线程也可以继续正常运行。
    ```

### java中线程状态

![线程状态图](线程状态图.jpg)

#### Runnable状态 
java中线程的就绪状态Ready与运行状态Running可以统称为。

1. 就绪状态 是指线程处在一个cpu的等待队列里面，等待cpu分配时间片运行
2. 运行状态就是 cpu运行当前线程

#### Teminated状态（终止状态）
当线程结束以后会进入这个状态，不能重新调用start，如果想重新start，需要重新new一个线程对象。

#### Blocked状态 (阻塞状态)
等待synchronized锁的时候进入Blocked状态，获得锁回到Runnable状态

#### Waiting状态
需要调用对应的方法才能解除状态

#### TimedWaiting状态
过一段时间自动恢复

## 锁

## synchronized锁

synchronized必须是可重入锁 记录重入次数

异常会释放synchronized锁，要注意捕获处理

synchronized(Object) 锁定对象 不能是String常量、Integer、Long等基础数据类型的包装类

**synchronized详解链接**

#### synchronized锁优化
锁细化
锁粗化

## 可重入锁Lock

### 什么时候用Lock什么时候用synchronized
线程少并且一次占用线程时间不长可以使用自旋锁
线程多，并且容易长时间执行占用锁，就使用synchronized锁


## 乐观锁cas

#### AtomicInteger

#### LongAdder


## CountDownLatch
```
CountDownLatch latch = new CountDonwLatch(100);

latch.CountDown();会让其内置计数减一

latch.await();会阻塞当前线程的方法，等待内置计数为0后才继续执行
```

## CyclicBarrier

```
CyclicBarrier barrier = new CyclicBarrier(20,()->{
   System.out.println("满人！发车！");
});//等待20个线程，然后会出发

for(int i=0;i<100;i++){
   new Thread(()->{
      barrier.await();//当来一个线程就阻塞住，直到20个线程放行
      System.out.println("20个齐了！我出发了");
   }).start();
}
```

## Phaser

```

```


## ReadWriteLock

```
读写锁 读锁为共享锁，与写锁冲突 写锁为独占锁，与写锁、读锁都冲突
```

## Semaphore
```
信号量 同步pv操作  限流 有几个信号量，就允许几个线程同时获得信号量并运行
Semaphore s = new Semaphore(1);
new Thread(()->{
   try{
      s.acquire();//阻塞方法
      System.out.println("T1 running");
   }catch(InterruptedException e){
      e.printStackTrace();
   }finally{
      s.release();
   }
}).start();
new Thread(()->{
   try{
      s.acquire();//阻塞方法
      System.out.println("T2 running");
   }catch(InterruptedException e){
      e.printStackTrace();
   }finally{
      s.release();
   }
}).start();

Semaphore s1 = new Semaphore(4,true);//true表示公平
队列先进先出获得信号量保证公平

```

## Exchanger
```
两个线程间的数据交换
Exchanger<String> exchanger = new Exchanger<>();

new Thread(()->{
   String s = "T1";
   try{
      s = exchanger.exchange(s);//阻塞方法
   }catch(InterruptedException e){
      e.printStackTrace();
   }
},"T1").start();

new Thread(()->{
   String s = "T2";
   try{
      s = exchanger.exchange(s);//阻塞方法，等另一个线程执行到这的时候交换数据，并解除阻塞，也可以设置时间，超时了就失败
   }catch(InterruptedException e){
      e.printStackTrace();
   }
},"T2").start();
```

## LockSupport
```
LockSuporrt.park()与unpack()//方法不需要锁对象即可实现
wait()/notify()的方法
而且unpark方法可限于park方法执行
```

## AQS