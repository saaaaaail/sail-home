---
title: 计算机网络知识点记录
date: 2020-07-17 20:40:59
tags:
- 计算机网络
---
# 计算机网络

## 物理层

## 链路层

## 网络层

### ip首部

### ip地址编址方式

### ARP地址解析协议

### ICMP

### VPN 虚拟专用网
指的是多个专用网络通过互联网作为各个网络间通信的载体，
比如我本地一台服务器要通过香港的服务器访问谷歌，中间要经过互联网传输，在出我本地专用网的时候的路由器R1会把我访问谷歌的ip包加密，然后包裹上香港专用网的路由器ip，经过互联网发送到香港服务器，然后进入香港专用网之前的路由器R2，给我删去头部，解密数据报，交付与谷歌进行通信。


### 路由

路由器负责路由选择与分组转发。

#### 路由分组转发过程
首先要了解路由表里存了些什么，目的网络(网络号)、下一跳ip(网关字段)(路由器的ip或者可以直接交付的目的主机ip)、目的网络的子网掩码、同局域网的交换机(网络号相同) 等等
- 从数据报首部获得目的主机的ip地址，
- 然后用这个ip与各个条目的子网掩码相与得到网络号，
- 判断这个计算出来的网络号是不是等于下一跳的网络号，如果是的，交付给进入目标网络的路由器ip
- 如果不仅网络号相同，并且下一跳就是目标网络，那就直接交付目的主机ip
- 如果没有匹配的，路由表里还有目的网络、子网掩码全0 的默认路由，这条路由一定能匹中，能就将数据报交给网关去传。

#### 路由选择协议


## 传输层
传输层主要是UDP与TCP。
### 介绍一下UDP。
用户数据报协议 是无连接的、尽最大努力交付、没有拥塞控制、而且是面向报文的即不拆分也不合并、支持一对一、一对多、多对多的交互通信方式。
### 介绍一下TCP。
传输控制协议 是面向连接的，提供可靠交付，具有流量控制，拥塞控制，支持全双工通信，面向字节流的即能根据字节序号拆分合并数据块，只能点对点通信。

### UDP首部格式
UDP首部字段只有8个字节，源端口2字节，目的端口2字节，整个数据包的长度2字节，检验和2字节。

### TCP首部格式
与ip首部固定的大小相同为20字节。  
2个字节的源端口，  
2个字节的目的端口，  
4个字节的序号，用于对字节流进行编号，序号为100表示第一个字节的编号为100，如果这个报文段长度为100，那么下一个报文段的序号就是200，      
4个字节的确认号，期望收到的下一个报文段的序号，如果收到的报文段序号为100，长度为100，那么期望收到的下个报文段的序号就是200，  
下面的数据占2字节:   
4位数据偏移表示tcp首部的长度，  
6位保留位，暂时没用
6个标志位:  
- URG : 当URG==1 表示高优先级数据，不按原来的顺序发送，插入到报文段数据最前面。
- ACK : 确认号，用于建立连接时以及连接建立以后都得置1。
- PSH : 当PSH==1 表示要求尽快交付的数据，接收端收到这个报文段以后立即交付，不用等缓存填满后再交付。
- RST : 当RST==1 用来拒绝一个非法报文段或者拒绝一个连接。
- SYN : 同步号，用来建立连接时同步序号，当SYN置1表示这是一个连接请求或者连接接受报文。
- FIN : 当FIN==1 表示发送完毕，并且要求释放连接。

2个字节的窗口，是接收方发给发送方的接收方一端数据缓存的大小限制。
2个字节的校验和，包括首部与数据范围。  
2个字节的紧急指针，指出紧急数据末尾的字节数。
4个字节的选项。

### TCP三次握手过程
- A为客户端，B为服务端。
- A向B发送请求连接的报文，SYN=1，ACK=0，选择一个初始的序号x。
- B收到连接请求的报文，如果同意建立连接，则向A发送连接确认的报文，SYN=1,ACK=1,确认号为x+1，同时也选择一个初始的序号y。
- A收到B的确认连接的报文后，向B发出确认报文，ACK=1,确认号为y+1，序号为x+1。
- B收到A的确认报文后，连接正常建立。

#### 为什么要进行第三次握手?
第三次握手是为了防止失效的连接请求到达服务器以后，让服务器打开错误的连接，如果A发给B的请求连接报文在网络中阻塞了，A这边超时重传了一个与B建立了连接，如果没有第三次确认，服务器收到了两个请求连接的报文，打开了两个连接，如果有三次握手，客户端会忽略服务器对网络阻塞的那个报文的连接确认报文，不再进行第三次握手，不会再次开启连接。

### TCP四次挥手过程
- A为客户端，B为服务端。
- A向B发送连接释放报文，ACK=1，FIN=1，序号当前已经记录到u了。
- B收到A的释放连接报文以后，B服务器这边的连接就半关闭状态（表示客户端没有数据要发了，但是服务器如果还有数据，仍然可以发给客户端接收），然后给A发送释放连接确认报文，ACK=1，序号记录到v了，确认号就是u+1
- 当B发完最后的数据以后，B向A发送连接释放报文，ACK=1，FIN=1，序号为w（服务器发完所有数据以后的），确认号为u+1（没变过），发送完后B就LAST_ACK状态，不会再发数据
- A收到B的连接释放报文以后，发送确认报文，ACK=1，序号为u+1，确认号为w+1，之后客户端进入TIME_WAIT状态，等待2MSL（报文最大生命时间）以后，客户端关闭，而服务端在收到这个确认报文后就关闭了

#### 为什么要四次挥手?
如果仅仅进行三次挥手，就向握手一样，在客户端释放连接的确认报文中释放服务端的连接，会导致服务端有剩余的数据还没有发完，因此服务端连接释放请求拆分出来，等待数据传送完毕以后服务端主动发送连接释放报文。

#### 为什么要等待2MSL？
确保最后一个确认报文能到达服务器端，因为如果这个确认报文丢了，服务器端超时会重传FIN报文，如果客户端在2MSL时间里面再次收到了服务器端的FIN报文就会再次等待2MSL，如果2MSL时间里也没有再次收到FIN报文，客户端认为服务器端是收到确认报文了，因此关闭连接。   
还一个作用是让本次连接的产生的所有报文段都从网络中消失。

### 三次握手 四次挥手 实例图
![三次握手四次挥手图](三次握手四次挥手图.jpg)
前三次为握手过程，中间为数据传输加确认，最后四次为挥手过程。

### 简单说一下TCP怎么保证可靠传输？
TCP的所有机制都是为了保证传输的可靠性。
1、校验和
2、序号+确认应答+滑动窗口  TCP基于字节流传输，因此每个数据都有自己的序号，接收方会按序接收
3、超时重传  TCP具有超时重传的策略，一个已经发送的报文段在超时时间内没有收到确认，就重传这个报文段。
4、流量控制
5、拥塞控制

### 简单说一下TCP的滑动窗口？
滑动窗口可以理解为发送方与接收方的缓存，发送方和接收方各有一个窗口，发送方的窗口根据接收方发来的TCP数据报里的窗口进行设置。
窗口的单位是字节，通过TCP的序号排列在窗口中，对于已经发送并确认的字节，窗口会右移直到第一个字节不是已发送并且已经确认的状态，
那么对于大小有限的窗口，其中包含的就是已发送未确认以及允许发送还没发的字节，
接收窗口左部的字节如果已经发送确认并交付主机，就右移直到未发送确认的字节，接收窗口会按序接收，并且只对最后一个连续的字节进行确认，  
比如，接收窗口里从第一个字节开始序号依次是51、52、53、54、55...... 那么，如果接收到的序号是51、54、55，那么接收方只会对51进行确认。

发送方接收到的确认序号能保证，这个序号之前的字节都已经确认接收了。

### 简单说一下流量控制？
流量控制是为了控制发送方的发送速率，保证接收方能及时接收。  
接收方通过确认报文里的TCP首部的窗口字段来控制发送方的的窗口大小。如果接收到的窗口大小为0，那么发送方就将停止发送数据。

### 简单说一下拥塞控制？
拥塞是网络状况出现问题分组可能丢失，需要控制发送方的速度，与流量控制很像，但是目的不一样，流量控制是为了接收方能及时接收发送方发来的数据，而拥塞控制是为了降低整个网络的拥塞情况。

TCP主要通过4个算法进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。

首先发送方维护一个叫拥塞窗口的变量cwnd，这只是一个状态变量，实际发送方能发多少数据取决于发送方的窗口。  
首先假设没有发生流量控制，发送方窗口不会影响cwnd。  
然后假设cwnd窗口的单位为报文段。

#### 慢开始与拥塞避免
> 下面的轮次的意思是指当前cwnd大小的报文段全部被确认。

发送刚开始cwnd窗口值为1，发送方只能发送一个报文段；当整个报文段都被确认以后，cwnd加倍，所以每个轮次的cwnd窗口值得报文段数据被确认以后，cwnd翻倍，依次为1、2、4、8......。  
这样窗口会增长得特别快，当达到慢开始门限ssthresh，cwnd>=ssthresh的时候就进入拥塞避免阶段，每轮次cwnd仅加1，如果出现了超时重传，就将慢开始门限设置为之前的一半ssthresh/2，然后重新cwnd=1开始慢开始阶段。

#### 快重传与快恢复

快重传机制是对超时重传机制的一种补充。
接收方每次接收到报文段都应该对最后一个已收到的连续报文段发送确认报文段，比如已经收到了M1、M2与M4，那么最终能确认的是ACK=2，如果此时又收到了M5、M6那么都会发送ACK=2的确认报文，如果发送方连续三次收到了冗余的相同的确认报文，这里就是ACK=2的报文段。那么发送方认为下一个序号的报文段丢失了，即M3，就会立即重传M3。

如果只是这种情况丢失个别报文段，可以执行快恢复，将慢查询门限ssthresh设置为当前窗口值cwnd的一半，并将窗口值cwnd设置为当前门限值开始，直接进入拥塞避免状态。

慢启动指的是从cwnd=1开始，而快恢复指的是从ssthresh/2的位置开始。是指cwnd值的大小，不是窗口增长速率。

当发生网络拥塞时会判断是网络拥塞还是仅仅丢了几个包，如果确认是网络拥塞的话就慢启动，如果仅仅只是丢了几个包，采用快恢复。

### Socket
套接字 ip+port->ip+port  是一对。左边与右边一起唯一确认
192.168.1.121:22->192.168.1.122:80 是一个套接字，左边的的主机端口也可以重复使用
192.168.1.121:22->192.168.1.121:80 这样两个套接字可以同时存在与192.168.1.121这个主机里面，即便套接字右边的客户端使用了同一个端口

## 应用层

### 什么是DNS系统？
DNS是一个分布式数据库，提供域名与ip地址的相互转换的服务。每个站点只保存自己的一部分数据。域名系统具有层次结构，从上到下为根域名、顶级域名、二级域名。DNS系统使用UDP或者TCP进行传输，端口号都为53，大多数情况下使用UDP，因此要求域名服务器自己进行超时重传与可靠性保证。
- 两种情况使用TCP，返回的数据超过512字节
- 区域传送，主域名服务器向辅助域名服务器同步变化的数据的时候。

### FTP文件传输协议？
使用TCP来建立连接，传输一个文件需要建立两个连接:
- 控制连接: 由客户端主动建立连接，服务端打开21号端口等待客户端的连接，连接建立以后，使用这个连接将客户端的命令传输给服务器端，并传回服务器的应答。
- 数据连接: 有两种模式:
  - 由服务器端主动建立的连接，这个服务器端的端口号是20号端口，客户端端口号随机，必须大于1024。
  - 服务器的被动模式，由客户端主动建立这个连接，客户端端口号自己指定，服务端端口号随机。


### 动态主机配置协议 DHCP
这个协议提供了即插即用的联网方式，不需要手动配置ip等信息。
这个协议自动配置了ip地址、子网掩码、网关ip地址。
DHCP配置过程如下：
- 由客户端主动发送Discover报文，目的地址是255.255.255.255:67是这个网段的广播地址，这个报文会使用UDP广播到子网的所有主机上面。如果客户端与DHCP服务器不在一个子网，还需要使用中继代理。
- DHCP服务器收到这个Discover报文以后就会给客户端发送offer报文段给客户端，包含客户端需要的ip信息。由于可能有多个DHCP服务器发送给客户端，客户端会进行选择。
- 客户端选择某个DHCP服务器以后，发送Request报文。
- DHCP服务器收到Request报文后回送ack报文，表示客户端此时可以使用它提供的信息。


### 电子邮件协议

### Web页面请求过程

#### 使用DHCP为主机分配ip

#### 浏览器访问目标域名

#### 向DNS域名解析系统查询域名的ip地址

#### 使用arp地址解析协议获取对应ip主机的mac地址

#### 三次握手建立TCP连接

#### 浏览器发送http请求给服务端

#### 服务端返回http响应给浏览器

#### 浏览器解析视图页面

### http协议

#### http首部

http请求报文的http首部由 请求行 与 首部字段 组成：
- 请求行包括 请求方法、URI、http版本
- 首部字段包括通用首部字段、响应首部字段、实体首部字段

http响应报文的http首部由 请求行 与 首部字段 组成：
- 请求行包括 http版本、响应码
- 首部字段包括通用首部字段、响应首部字段、实体首部字段

#### http方法
##### get 
通常用于请求获取服务器的资源
##### post
用于向服务器发送数据
##### put
用于向服务器修改数据
##### delete
用于请求服务器删除数据
##### options
预请求，用于判断接下来的请求是否可行

##### GET和POST的比较
GET的参数以键值对的方式拼接在url后面，而POST的参数存储在报文正文里面。不能因为post的参数存储在实体里面就认为安全性能比GET高，在不加密的情况下POST的包仍然可以通过抓包获得。

由于url只支持ascii码，因此对于中文字符空格等进行百分号编码。而post实体参数支持标准字符集，现在一般是utf-8。
GET方法是幂等的安全的只读的，不会修改服务器状态，因此可以进行缓存，而POST不是，POST请求肯定是要求服务器做某件事情的，在不人为保证幂等的情况下，每次请求都是不同的，重复请求肯定会出问题的。

浏览器中的GET和POST和接口中的GET和POST是不一样的。

- 浏览器中的GET请求可以理解为没有body，只有url，请求数据放在queryString中，POST都来自表单提交，数据都放在body里面，两种格式application/x-www-form-urlencoded、multipart/form-data。

- 接口中的GET请求和POST请求很自由，数据均可以放在head、queryString、body中，因此使用REST接口规范对GET、POST、PUT、DELETE进行了规定。

###### 关于POST发两个请求吗？
发两个请求是指先发请求头给服务端，根据返回结果如果是100 Continued继续发请求体，如果是4xx系列或者其他状态码就停止发送。

是一种优化策略，但不是一定的，也可以一次性发给服务端。

可以根据请求头部的鉴权信息决定是否继续发送请求体。

可以根据请求体的大小决定是否需要分开发。等等~

**XMLHttpRequest**: 
#### http状态码

##### 1xx
100 表示目前为止正常，可以继续也可以忽略
##### 2xx
200系列均表示请求成功。

##### 3xx
300系列表示这个请求经过重定向，被分配了新的url。

##### 4xx
400系列表示客户端的错误。
- 400表示报文格式语法不对。
- 401表示未鉴权，鉴权失败。
- 403表示请求资源被拒绝。
- 404表示资源没找到。
- 408表示请求超时。

##### 5xx
500系列表示服务端的错误。
- 500表示服务端执行时出错，npe或者代码bug
- 503表示服务未启动，或者服务挂了。

#### 长连接与短链接
http 1.0版本是默认短连接支持长连接，短连接指的是一次请求响应以后就会断开tcp连接。
http 1.1版本是默认长连接支持短连接，长连接指的是建立一次tcp连接就能进行多次http通信。

#### pipeling
http 1.1支持的流水线方式，默认情况下即一次请求等到响应回来再进行下一次请求，由于受到网络延迟和带宽的影响，在下一个请求到来之前，可能需要等待很长时间，pipeline支持的是在一条tcp连接上面连续发出请求，不用等待响应返回，但是响应的接收仍然是按照请求顺序接收的。

#### 什么是Cookie? 什么是session？区别？
##### Cookie
http协议是无状态的，为了能高效的处理事务所以没有复杂的设计，因此需要使用Cookie来保存状态信息。
**Cookie**是第一次请求服务器时发送浏览器并保存在本地的一块数据，之后访问同一个服务器时每个请求都会被携带上。
**Cookie用途**：   
- 会话状态管理
- 个性化设置
- 浏览器行为追踪

在第一次请求响应的头部会包含Set-Cookie字段，客户端浏览器把Cookie保存在浏览器中。之后的请求头部都会携带上Cookie字段，发送给服务器。

**有效期**：  
默认的Cookie当浏览器被关闭后会被自动删除，仅在会话期有效。如果指定了过期时间(Expires)或者有效期(max-age)后就能持久存在。

##### Session
**Session**是在服务端用来记录会话状态标识具体用户的机制。存储在服务端的数据更安全，而且可以存储任意类型的数据，可以存储在服务器文件上、内存里、数据库里、redis中 等。

使用Session维护用户登录状态的过程如下：
- 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
- 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
- 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
- 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。

对于极其安全的场景，不能仅仅使用Session维持登录状态，需要重新验证密码。

##### 区别
Cookie只能存储Ascii码字符串，而Session可以存储任意类型数据。
Cookie存储在浏览器端，隐私安全数据不建议存储在Cookie中，如果一定要存储在Cookie中一定要进行加密。Session保存在服务端也更安全。

#### 代理

##### 为什么要使用代理？
使用代理可以做哪些事情呢？一是作为缓存，在代理服务器上暂存网络资源。二是作负载均衡使用，代理服务器将请求以一定策略分发到不同的主机上面。三是作网络访问控制，将目标主机隐藏起来，或者访问内网的时候都经过代理服务器。四是访问日志记录。

###### 正向代理
正向代理就是指由客户端经过代理服务器访问目标服务器的过程。举例就是浏览器不能直接访问谷歌，因此先人为指定一个代理服务器，由这个代理服务器访问谷歌，然后由代理服务器将访问结果返回给浏览器。
###### 反向代理
反向代理是指在一个内网里面，代理服务器接受到来自互联网的请求，并将这个请求转发或者分发给内网中的其他服务器主机。

#### https
##### http面临的问题
- http使用明文通信，内容可能被窃听。
- 通信方的身份不进行验证，有可能被伪装。
- 无法证明报文的内容完整性，内容有可能被修改。

https是协议是指让http先和ssl通信，再让ssl和tcp通信。通过使用ssl，https具有了内容加密、身份认证、和内容完整性保护。

##### 加密
###### 对称密钥加密
加密和解密使用同一密钥。优缺：运算速度快、无法安全的传输密钥。
###### 非对称密钥加密
密钥分为公钥和私钥一对。    
公钥所有人都可以获得，私钥并不在网络上传输。优缺：可以将公钥传输给对方，加密速度慢。

- 可以使用发送方公钥加密，接受方私钥解密，保证加密文件传输的安全性。
- 可以使用发送方私钥加密，接受方公钥解密，这是数字签名技术，即使用发送者的公钥解密了发送者的私钥，说明认证了发送方。

###### https的加密
https的加密同时使用了这两种加密技术。
- 对于数据的加密使用对称加密方式SecretKey进行通信保证效率。
- 对于数据对称加密的密钥SecretKey采用非对称加密的方式，保证安全性。

以上解决了数据加密、以及内容篡改的问题，但是对于身份认证，需要一个中立机构来签发证书，证明公钥。

##### 认证
CA（Cerficate Authority）数字证书认证机构是客户端与服务端都信任的第三方机构。
- 服务器向CA提交公钥申请，CA认证完服务器的身份以后就会使用CA的私钥对这个服务器的公钥进行数字签名，将签名完以后的公钥与服务器证书绑定在一起。
- 那么浏览器在与服务器进行https通信之前，会先与CA进行https通信获得，使用CA的公钥解密服务器的公钥，以保证安全获得对应服务器的公钥。
- 然后与服务器进行https通信，拿着服务器的公钥解密数据对称加密的密钥SecretKey进行解密，获得解密后的SecrtKey，然后对数据进行解密。

##### https缺点
- 加密解密影响效率
- CA认证费用高昂


#### http版本问题 

##### http1.x缺陷
- 客户端需要同时建立多个连接才能实现并发
- 不压缩请求和响应首部，浪费网络流量
- 不支持资源优先级，tcp利用率不高

##### http1.1新特性
- 默认长连接
- 支持流水线方式
- 支持同时打开多个tcp连接
- 新增缓存处理指令cache-control max-age 
- 支持虚拟主机
- 新增状态码 100
- 支持分块传输编码

##### http2.0介绍
###### 二进制帧
于http1.x的文本字符消息的报文不同，http2.0将报文分为HEADERS帧和DATA帧，里面存储的是压缩过的原数据，它们都是二进制帧的形式，对于不同的帧格式他们的首部9个字节是相同的，用于标识一个帧。
在通信过程中只有一个tcp连接，但是可以同时进行多条双向数据流Stream，假定一次请求和响应为一条数据流，具有唯一数据流标识和优先级信息

这样不同数据流的帧就可以交错发送，然后根据帧头的数据流标识重新组装，这也是http2.0能实现多路复用的前提，打破了一个请求等待一个响应的相对顺序。
###### 服务端推送
浏览器在请求一个资源的时候，http2.0会将相关资源一并返回给客户端。
###### 首部压缩
- http2.0要求客户端和服务端对首部字段同时维护一个字段表，如果字段更新了就添加到首部，如果没有更新就读取本地存储的。
- http2.0使用huffman编码对首部字段进行压缩。  



