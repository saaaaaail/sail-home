---
title: 计算机网络知识点记录
date: 2020-07-17 20:40:59
tags:
- 计算机网络
---
# 计算机网络

## 物理层

## 链路层

### 数据成帧
链路层对数据封装成帧，给网络层传下来的分组添加首部尾部，标记为一个帧。

### 透明传输
透明传输传的是转义字符，为了避免数据帧与结束标识符相同，需要给数据帧中的结束标识符前面加上转移标识符，在取出数据的时候会消掉，因此是透明的

### 差错检测
循环冗余检验（CRC）来检查比特差错。

### 信道分类

#### 广播信道
这种是一对多，同时有多个节点要使用广播信道，因此就要避免冲突。  
避免冲突的方式有 信道复用技术 与 CSMA/CD协议 

#### 点对点信道
这种一对一通信，比较简单使用ppp协议进行控制

### 信道复用技术

#### 频分复用
不同节点主机 同时使用信道，但是占用不同的频率带宽资源。  

#### 时分复用
不同节点主机 占用相同的频率带宽，但是占用不同的时间片

#### 统计时分复用
以上两种都是提前规定了信道使用的方式，利用率很低。   
这种 不固定不同主机使用时分复用帧的顺序或者位置，有数据来就集中起来组成统计时分复用帧发生。

#### 波分复用
光的频分复用。对于光 常使用波长来表示光载波。  

#### 码分复用
即给每个用户分配 m bit的码片，不同用户的码片相交 是等于0，那么m bit位组成一个串S就可以表示一个用户的 1 ，!S反码表示0。这样组成一个二进制串，是原串长度的m倍，接收的时候使用S对接收的数据进行内积运算，为0是其他用户的码片数据，为1就是我自己的比特数据1，为-1就是我自己的比特数据0.  

### CMSA/CD协议
载波监听、多点接入/碰撞检测
- 载波监听： 每个主机不停地监听信道，发送前信道在使用就必须等待。
- 多点接入： 总线型网络，许多主机以多点的方式连接到总线上。
- 碰撞检测： 在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。

记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。

当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。

### PPP协议

互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。

  PPP 的帧格式 顺序依次向下：

  F 字段为帧的定界符
  A 和 C 字段暂时没有意义
  上层使用协议
  信息部分的长度不超过 1500
  FCS 字段是使用 CRC 的检验序列
  F 字段为帧的定界符
  
### MAC地址
MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。

一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。

### 局域网

#### 以太网
以太网是一种星型拓扑结构局域网。

早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。

目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。

以太网帧格式：

类型 ：标记上层使用的协议；
数据 ：长度在 46-1500 之间，如果太小则需要填充；
FCS ：帧检验序列，使用的是 CRC 检验方法；

### 交换机
交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。

接口指的是连接到交换机上的那一条线路的MAC地址。

## 网络层

### ip首部
ip首部大小固定20字节: 
**4位的版本号**：有 4（IPv4）和 6（IPv6）两个值；
**4位的首部长度**：最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。
**1个字节的区分服务**  
**2个字节的首部加数据长度**
**2个字节的标识符**：用来唯一标识一份数据报，每发送一个加1
**3位标志和13位片偏移**：标志表明这些分组属于同一数据报，片偏移表示当前数据报数据首部位置位于总数据报数据段的位置，但是这里片偏移的单位是8字节，即真实的偏移量是1400字节的话，这个表里填175
**1个字节的生存时间**：TTL,表示路由器跳数
**1个字节的协议字段**：表示数据包上层移交给哪个协议
**2个字节的首部校验和**  
**4个字节的源地址**    
**4个字节的目的地址**

### ip地址编址方式
- 分类 A、B、C、D 四类
- 子网划分 
- 无分类 CIDR (网络前缀号+主机号)

### ARP地址解析协议
网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。

ARP 实现由 IP 地址得到 MAC 地址。

每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。

如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。

### ICMP

1. Ping
Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。

Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。

2. Traceroute
Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。

Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。

源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；
源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。
不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。
之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。

### VPN 虚拟专用网
指的是多个专用网络通过互联网作为各个网络间通信的载体，
比如我本地一台服务器要通过香港的服务器访问谷歌，中间要经过互联网传输，在出我本地专用网的时候的路由器R1会把我访问谷歌的ip包加密，然后包裹上香港专用网的路由器ip，经过互联网发送到香港服务器，然后进入香港专用网之前的路由器R2，给我删去头部，解密数据报，交付与谷歌进行通信。

虚拟隧道技术。


### NAT


### 路由
路由器从功能上可以划分为：路由选择和分组转发。

分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。

路由器负责路由选择与分组转发。

#### 路由分组转发过程
首先要了解路由表里存了些什么，目的网络(网络号)、下一跳ip(网关字段)(路由器的ip或者可以直接交付的目的主机ip)、目的网络的子网掩码、同局域网的交换机(网络号相同) 等等
- 从数据报首部获得目的主机的ip地址，
- 然后用这个ip与各个条目的子网掩码相与得到网络号，
- 判断这个计算出来的网络号是不是等于下一跳的网络号，如果是的，交付给进入目标网络的路由器ip
- 如果不仅网络号相同，并且下一跳就是目标网络，那就直接交付目的主机ip
- 如果没有匹配的，路由表里还有目的网络、子网掩码全0 的默认路由，这条路由一定能匹中，能就将数据报交给网关去传。

#### 路由选择协议
路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。

互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。

可以把路由选择协议划分为两大类：

自治系统内部的路由选择：RIP 和 OSPF
自治系统间的路由选择：BGP

1. 内部网关协议 RIP
RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。

RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。

距离向量算法：

对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；
对修改后的 RIP 报文中的每一个项目，进行以下步骤：
若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；
否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。
若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。
RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。

2. 内部网关协议 OSPF
开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。

开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF 就是dijkstra算法。

OSPF 具有以下特点：

每个路由器节点会向本自治系统中的所有路由器发送信息，这种方法是洪泛法。
发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。
只有当链路状态发生变化时，路由器才会发送信息。
所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。

3. 外部网关协议 BGP
BGP（Border Gateway Protocol，边界网关协议）

AS 之间的路由选择很困难，主要是由于：

互联网规模很大；
各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；
AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。
BGP 只能寻找一条比较好的路由，而不是最佳路由。

每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。



## 传输层
传输层主要是UDP与TCP。
### 介绍一下UDP。
用户数据报协议 是无连接的、尽最大努力交付、没有拥塞控制、而且是面向报文的即不拆分也不合并、支持一对一、一对多、多对多的交互通信方式。
### 介绍一下TCP。
传输控制协议 是面向连接的，提供可靠交付，具有流量控制，拥塞控制，支持全双工通信，面向字节流的即能根据字节序号拆分合并数据块，只能点对点通信。

### UDP首部格式
UDP首部字段只有8个字节，源端口2字节，目的端口2字节，整个数据包的长度2字节，检验和2字节。

### TCP首部格式
与ip首部固定的大小相同为20字节。  
2个字节的源端口，  
2个字节的目的端口，  
4个字节的序号，用于对字节流进行编号，序号为100表示第一个字节的编号为100，如果这个报文段长度为100，那么下一个报文段的序号就是200，      
4个字节的确认号，期望收到的下一个报文段的序号，如果收到的报文段序号为100，长度为100，那么期望收到的下个报文段的序号就是200，  
下面的数据占2字节:   
4位数据偏移表示tcp首部的长度，  
6位保留位，暂时没用
6个标志位:  
- URG : 当URG==1 表示高优先级数据，不按原来的顺序发送，插入到报文段数据最前面。
- ACK : 确认号，用于建立连接时以及连接建立以后都得置1。
- PSH : 当PSH==1 表示要求尽快交付的数据，接收端收到这个报文段以后立即交付，不用等缓存填满后再交付。
- RST : 当RST==1 用来拒绝一个非法报文段或者拒绝一个连接。
- SYN : 同步号，用来建立连接时同步序号，当SYN置1表示这是一个连接请求或者连接接受报文。
- FIN : 当FIN==1 表示发送完毕，并且要求释放连接。

2个字节的窗口，是接收方发给发送方的接收方一端数据缓存的大小限制。
2个字节的校验和，包括首部与数据范围。  
2个字节的紧急指针，指出紧急数据末尾的字节数。
4个字节的选项。

### TCP粘包拆包
粘包指的是一个数据包中包含了两个数据包的情况，并且接收端不知道数据包的界限，所以对于接收端来说很难处理。
1. 要发送的数据大于TCP的缓冲区剩余大小，会发生拆包。
2. 待发送数据大于MSS，TCP在传输前会拆包。
3. 要发送的数据小于TCP缓冲区的大小，TCP就会多次写入缓冲区然后一次发送出去，这里会发生粘包。
4. 接收数据端的应用层没有及时读取接收缓冲区的数据将发生粘包。

解决方案：  
1. 在每一个数据包添加首部，在首部中包含一个数据包的长度，这样接收方收到以后通过读取首部字段就能知道。
2. 发送端将数据包封装为固定长度，不够补0，接收端每次从接收缓冲区里面取固定长度即可
3. 可以在数据包之间设置边界，特殊符号，通过匹配特殊符号来区分数据包。

### Tcp报文大小
MTU: Maxitum Transmission Unit 最大传输单元  
MSS: Maxitum Segment Size 最大分段大小  
在链路层的以太网协议中MTU的值为1500字节  
所以减去ip层首部20个字节，减去tcp层首部20个字节，在以太网中TCP的MSS为1460字节大小。

### TCP三次握手过程
- A为客户端，B为服务端。
- A向B发送请求连接的报文，SYN=1，ACK=0，选择一个初始的序号x。
- B收到连接请求的报文，如果同意建立连接，则向A发送连接确认的报文，SYN=1,ACK=1,确认号为x+1，同时也选择一个初始的序号y。
- A收到B的确认连接的报文后，向B发出确认报文，ACK=1,确认号为y+1，序号为x+1。
- B收到A的确认报文后，连接正常建立。

#### 为什么要进行第三次握手?
第三次握手是为了防止失效的连接请求到达服务器以后，让服务器打开错误的连接，如果A发给B的请求连接报文在网络中阻塞了，A这边超时重传了一个与B建立了连接，如果没有第三次确认，服务器收到了两个请求连接的报文，打开了两个连接，如果有三次握手，客户端会忽略服务器对网络阻塞的那个报文的连接确认报文，不再进行第三次握手，不会再次开启连接。

### TCP四次挥手过程
- A为客户端，B为服务端。
- A向B发送连接释放报文，ACK=1，FIN=1，序号当前已经记录到u了。
- B收到A的释放连接报文以后，B服务器这边的连接就半关闭状态（表示客户端没有数据要发了，但是服务器如果还有数据，仍然可以发给客户端接收），然后给A发送释放连接确认报文，ACK=1，序号记录到v了，确认号就是u+1
- 当B发完最后的数据以后，B向A发送连接释放报文，ACK=1，FIN=1，序号为w（服务器发完所有数据以后的），确认号为u+1（没变过），发送完后B就LAST_ACK状态，不会再发数据
- A收到B的连接释放报文以后，发送确认报文，ACK=1，序号为u+1，确认号为w+1，之后客户端进入TIME_WAIT状态，等待2MSL（报文最大生命时间）以后，客户端关闭，而服务端在收到这个确认报文后就关闭了

> 如何尽快结束time wait状态？
> 

#### 为什么要四次挥手?
如果仅仅进行三次挥手，就向握手一样，在客户端释放连接的确认报文中释放服务端的连接，会导致服务端有剩余的数据还没有发完，因此服务端连接释放请求拆分出来，等待数据传送完毕以后服务端主动发送连接释放报文。

#### 为什么要等待2MSL？
确保最后一个确认报文能到达服务器端，因为如果这个确认报文丢了，服务器端超时会重传FIN报文，如果客户端在2MSL时间里面再次收到了服务器端的FIN报文就会再次等待2MSL，如果2MSL时间里也没有再次收到FIN报文，客户端认为服务器端是收到确认报文了，因此关闭连接。   
还一个作用是让本次连接的产生的所有报文段都从网络中消失。


### 三次握手 四次挥手 实例图
![三次握手四次挥手图](三次握手四次挥手图.jpg)
前三次为握手过程，中间为数据传输加确认，最后四次为挥手过程。

### 简单说一下TCP怎么保证可靠传输？
TCP的所有机制都是为了保证传输的可靠性。
1、校验和
2、序号+确认应答+滑动窗口  TCP基于字节流传输，因此每个数据都有自己的序号，接收方会按序接收
3、超时重传  TCP具有超时重传的策略，一个已经发送的报文段在超时时间内没有收到确认，就重传这个报文段。
4、流量控制
5、拥塞控制

### 简单说一下TCP的滑动窗口？
滑动窗口可以理解为发送方与接收方的缓存，发送方和接收方各有一个窗口，发送方的窗口根据接收方发来的TCP数据报里的窗口进行设置。
窗口的单位是字节，通过TCP的序号排列在窗口中，对于已经发送并确认的字节，窗口会右移直到第一个字节不是已发送并且已经确认的状态，
那么对于大小有限的窗口，其中包含的就是已发送未确认以及允许发送还没发的字节，
接收窗口左部的字节如果已经发送确认并交付主机，就右移直到未发送确认的字节，接收窗口会按序接收，并且只对最后一个连续的字节进行确认，  
比如，接收窗口里从第一个字节开始序号依次是51、52、53、54、55...... 那么，如果接收到的序号是51、54、55，那么接收方只会对51进行确认。

发送方接收到的确认序号能保证，这个序号之前的字节都已经确认接收了。

### 简单说一下流量控制？
流量控制是为了控制发送方的发送速率，保证接收方能及时接收。  
接收方通过确认报文里的TCP首部的窗口字段来控制发送方的的窗口大小。如果接收到的窗口大小为0，那么发送方就将停止发送数据。

### 简单说一下拥塞控制？
拥塞是网络状况出现问题分组可能丢失，需要控制发送方的速度，与流量控制很像，但是目的不一样，流量控制是为了接收方能及时接收发送方发来的数据，而拥塞控制是为了降低整个网络的拥塞情况。

TCP主要通过4个算法进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。

首先发送方维护一个叫拥塞窗口的变量cwnd，这只是一个状态变量，实际发送方能发多少数据取决于发送方的窗口。  
首先假设没有发生流量控制，发送方窗口不会影响cwnd。  
然后假设cwnd窗口的单位为报文段。

#### 慢开始与拥塞避免
> 下面的轮次的意思是指当前cwnd大小的报文段全部被确认。

发送刚开始cwnd窗口值为1，发送方只能发送一个报文段；当整个报文段都被确认以后，cwnd加倍，所以每个轮次的cwnd窗口值得报文段数据被确认以后，cwnd翻倍，依次为1、2、4、8......。  
这样窗口会增长得特别快，当达到慢开始门限ssthresh，cwnd>=ssthresh的时候就进入拥塞避免阶段，每轮次cwnd仅加1，如果出现了超时重传，就将慢开始门限设置为之前的一半ssthresh/2，然后重新cwnd=1开始慢开始阶段。

#### 快重传与快恢复

快重传机制是对超时重传机制的一种补充。
接收方每次接收到报文段都应该对最后一个已收到的连续报文段发送确认报文段，比如已经收到了M1、M2与M4，那么最终能确认的是ACK=2，如果此时又收到了M5、M6那么都会发送ACK=2的确认报文，如果发送方连续三次收到了冗余的相同的确认报文，这里就是ACK=2的报文段。那么发送方认为下一个序号的报文段丢失了，即M3，就会立即重传M3。

如果只是这种情况丢失个别报文段，可以执行快恢复，将慢查询门限ssthresh设置为当前窗口值cwnd的一半，并将窗口值cwnd设置为当前门限值开始，直接进入拥塞避免状态。

慢启动指的是从cwnd=1开始，而快恢复指的是从ssthresh/2的位置开始。是指cwnd值的大小，不是窗口增长速率。

当发生网络拥塞时会判断是网络拥塞还是仅仅丢了几个包，如果确认是网络拥塞的话就慢启动，如果仅仅只是丢了几个包，采用快恢复。

### Socket
套接字 ip+port->ip+port  是一对。左边与右边一起唯一确认
192.168.1.121:22->192.168.1.122:80 是一个套接字，左边的的主机端口也可以重复使用
192.168.1.121:22->192.168.1.121:80 这样两个套接字可以同时存在与192.168.1.121这个主机里面，即便套接字右边的客户端使用了同一个端口

## 应用层

### 什么是DNS系统？
DNS是一个分布式数据库，提供域名与ip地址的相互转换的服务。每个站点只保存自己的一部分数据。域名系统具有层次结构，从上到下为根域名、顶级域名、二级域名。DNS系统使用UDP或者TCP进行传输，端口号都为53，大多数情况下使用UDP，因此要求域名服务器自己进行超时重传与可靠性保证。
- 两种情况使用TCP，返回的数据超过512字节
- 区域传送，主域名服务器向辅助域名服务器同步变化的数据的时候。

### FTP文件传输协议？
使用TCP来建立连接，传输一个文件需要建立两个连接:
- 控制连接: 由客户端主动建立连接，服务端打开21号端口等待客户端的连接，连接建立以后，使用这个连接将客户端的命令传输给服务器端，并传回服务器的应答。
- 数据连接: 有两种模式:
  - 由服务器端主动建立的连接，这个服务器端的端口号是20号端口，客户端端口号随机，必须大于1024。
  - 服务器的被动模式，由客户端主动建立这个连接，客户端端口号自己指定，服务端端口号随机。


### 动态主机配置协议 DHCP
这个协议提供了即插即用的联网方式，不需要手动配置ip等信息。
这个协议自动配置了ip地址、子网掩码、网关ip地址。
DHCP配置过程如下：
- 由客户端主动发送Discover报文，目的地址是255.255.255.255:67是这个网段的广播地址，这个报文会使用UDP广播到子网的所有主机上面。如果客户端与DHCP服务器不在一个子网，还需要使用中继代理。
- DHCP服务器收到这个Discover报文以后就会给客户端发送offer报文段给客户端，包含客户端需要的ip信息。由于可能有多个DHCP服务器发送给客户端，客户端会进行选择。
- 客户端选择某个DHCP服务器以后，发送Request报文。
- DHCP服务器收到Request报文后回送ack报文，表示客户端此时可以使用它提供的信息。


### 电子邮件协议

### Web页面请求过程

#### 使用DHCP为主机分配ip

#### 浏览器访问目标域名

#### 向DNS域名解析系统查询域名的ip地址

#### 使用arp地址解析协议获取对应ip主机的mac地址

#### 三次握手建立TCP连接

#### 浏览器发送http请求给服务端

#### 服务端返回http响应给浏览器

#### 浏览器解析视图页面

### http协议
http是是应用层的无状态的超文本协议，基于tcp协议实现。

#### http首部

http请求报文的http首部由 请求行 与 首部字段 组成：
- 请求行包括 请求方法、URI、http版本
- 首部字段包括通用首部字段、请求首部字段、实体首部字段
- 请求首部字段：Accept、Accept-Charset、Accept-Encoding、Accept-Language、Host、Connection（keep-alive）
- 通用首部字段：Allow（客户端能支持的所有方法）、Content-Type、Content-Length、Content-Encoding、Content-Language、Cookie、Cache-Control（缓存控制）

http响应报文的http首部由 请求行 与 首部字段 组成：
- 请求行包括 http版本、响应码
- 首部字段包括通用首部字段、响应首部字段、实体首部字段
- Expires（指定缓存过期时间节点）、Set-Cookie、Location、Content-Type、Content-Length、Content-Encoding、Content-Language

#### http方法
##### get 
通常用于请求获取服务器的资源
##### post
用于向服务器发送数据
##### put
用于向服务器修改数据
##### delete
用于请求服务器删除数据
##### options
预请求，用于判断接下来的请求是否可行

##### GET和POST的比较
GET的参数以键值对的方式拼接在url后面，而POST的参数存储在报文正文里面。不能因为post的参数存储在实体里面就认为安全性能比GET高，在不加密的情况下POST的包仍然可以通过抓包获得。

由于url只支持ascii码，因此对于中文字符空格等进行百分号编码。而post实体参数支持标准字符集，现在一般是utf-8。
GET方法是幂等的安全的只读的，不会修改服务器状态，因此可以进行缓存，而POST不是，POST请求肯定是要求服务器做某件事情的，在不人为保证幂等的情况下，每次请求都是不同的，重复请求肯定会出问题的。

浏览器中的GET和POST和接口中的GET和POST是不一样的。

- 浏览器中的GET请求可以理解为没有body，只有url，请求数据放在queryString中，POST都来自表单提交，数据都放在body里面，两种格式application/x-www-form-urlencoded、multipart/form-data。

- 接口中的GET请求和POST请求很自由，数据均可以放在head、queryString、body中，因此使用REST接口规范对GET、POST、PUT、DELETE进行了规定。

###### 关于POST发两个请求吗？
发两个请求是指先发请求头给服务端，根据返回结果如果是100 Continued继续发请求体，如果是4xx系列或者其他状态码就停止发送。

是一种优化策略，但不是一定的，也可以一次性发给服务端。

可以根据请求头部的鉴权信息决定是否继续发送请求体。

可以根据请求体的大小决定是否需要分开发。等等~

**XMLHttpRequest**:   
为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：

XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。

在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。
而 GET 方法 Header 和 Data 会一起发送。

#### http状态码

##### 1xx
100 表示目前为止正常，可以继续也可以忽略
##### 2xx
200系列均表示请求成功。

##### 3xx
300系列表示这个请求经过重定向，被分配了新的url。

##### 4xx
400系列表示客户端的错误。
- 400表示报文格式语法不对。
- 401表示未鉴权，鉴权失败。
- 403表示请求资源被拒绝。
- 404表示资源没找到。
- 405表示请求超时。

##### 5xx
500系列表示服务端的错误。
- 500表示服务端执行时出错，npe或者代码bug
- 503表示服务未启动，或者服务挂了。

#### 长连接与短链接
http 1.0版本是默认短连接支持长连接，短连接指的是一次请求响应以后就会断开tcp连接。
http 1.1版本是默认长连接支持短连接，长连接指的是建立一次tcp连接就能进行多次http通信。

#### pipeling
http 1.1支持的流水线方式，默认情况下即一次请求等到响应回来再进行下一次请求，由于受到网络延迟和带宽的影响，在下一个请求到来之前，可能需要等待很长时间，pipeline支持的是在一条tcp连接上面连续发出请求，不用等待响应返回，但是响应的接收仍然是按照请求顺序接收的。

#### 什么是Cookie? 什么是session？区别？
##### Cookie
http协议是无状态的，为了能高效的处理事务所以没有复杂的设计，因此需要使用Cookie来保存状态信息。
**Cookie**是第一次请求服务器时发送浏览器并保存在本地的一块数据，之后访问同一个服务器时每个请求都会被携带上。
**Cookie用途**：   
- 会话状态管理
- 个性化设置
- 浏览器行为追踪

在第一次请求响应的头部会包含Set-Cookie字段，客户端浏览器把Cookie保存在浏览器中。之后的请求头部都会携带上Cookie字段，发送给服务器。

**有效期**：  
默认的Cookie当浏览器被关闭后会被自动删除，仅在会话期有效。如果指定了过期时间(Expires)或者有效期(max-age)后就能持久存在。

##### Session
**Session**是在服务端用来记录会话状态标识具体用户的机制。存储在服务端的数据更安全，而且可以存储任意类型的数据，可以存储在服务器文件上、内存里、数据库里、redis中 等。

使用Session维护用户登录状态的过程如下：
- 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
- 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
- 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
- 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。

对于极其安全的场景，不能仅仅使用Session维持登录状态，需要重新验证密码。

##### 区别
Cookie只能存储Ascii码字符串，而Session可以存储任意类型数据。
Cookie存储在浏览器端，隐私安全数据不建议存储在Cookie中，如果一定要存储在Cookie中一定要进行加密。Session保存在服务端也更安全。

#### 代理

##### 为什么要使用代理？
使用代理可以做哪些事情呢？一是作为缓存，在代理服务器上暂存网络资源。二是作负载均衡使用，代理服务器将请求以一定策略分发到不同的主机上面。三是作网络访问控制，将目标主机隐藏起来，或者访问内网的时候都经过代理服务器。四是访问日志记录。

###### 正向代理
正向代理就是指由客户端经过代理服务器访问目标服务器的过程。举例就是浏览器不能直接访问谷歌，因此先人为指定一个代理服务器，由这个代理服务器访问谷歌，然后由代理服务器将访问结果返回给浏览器。
###### 反向代理
反向代理是指在一个内网里面，代理服务器接受到来自互联网的请求，并将这个请求转发或者分发给内网中的其他服务器主机。

#### https
##### http面临的问题
- http使用明文通信，内容可能被窃听。
- 通信方的身份不进行验证，有可能被伪装。
- 无法证明报文的内容完整性，内容有可能被修改。

https是协议是指让http先和ssl通信，再让ssl和tcp通信。通过使用ssl，https具有了内容加密、身份认证、和内容完整性保护。

##### 加密
###### 对称密钥加密
加密和解密使用同一密钥。优缺：运算速度快、无法安全的传输密钥。
###### 非对称密钥加密
密钥分为公钥和私钥一对。    
公钥所有人都可以获得，私钥并不在网络上传输。优缺：可以将公钥传输给对方，加密速度慢。

- 可以使用发送方公钥加密，接受方私钥解密，保证加密文件传输的安全性。
- 可以使用发送方私钥加密，接受方公钥解密，这是数字签名技术，即使用发送者的公钥解密了发送者的私钥，说明认证了发送方。

###### https的加密
https的加密同时使用了这两种加密技术。
- 对于数据的加密使用对称加密方式SecretKey进行通信保证效率。
- 对于数据对称加密的密钥SecretKey采用非对称加密的方式，保证安全性。

以上解决了数据加密、以及内容篡改的问题，但是对于身份认证，需要一个中立机构来签发证书，证明公钥。

https ssl通道建立的过程：  
- 在使用HTTPS是需要保证服务端配置正确了对应的安全证书

- 客户端发送请求到服务端

- 服务端返回公钥和证书到客户端

- 客户端接收后会验证证书的安全性,如果通过则会随机生成一个随机数,用公钥对其加密,发送到服务端

- 服务端接受到这个加密后的随机数后会用私钥对其解密得到真正的随机数,随后用这个随机数当做私钥对需要发送的数据进行对称加密

- 客户端在接收到加密后的数据使用私钥(即生成的随机值)对数据进行解密并且解析数据呈现结果给客户

- SSL加密建立

##### 认证
CA（Cerficate Authority）数字证书认证机构是客户端与服务端都信任的第三方机构。
- 服务器向CA提交公钥申请，CA认证完服务器的身份以后就会使用CA的私钥对这个服务器的公钥进行数字签名，将签名完以后的公钥与服务器证书绑定在一起。
- 那么浏览器在与服务器进行https通信之前，会先与CA进行https通信获得，使用CA的公钥解密服务器的公钥，以保证安全获得对应服务器的公钥。
- 然后与服务器进行https通信，拿着服务器的公钥解密数据对称加密的密钥SecretKey进行解密，获得解密后的SecrtKey，然后对数据进行解密。

##### https缺点
- 加密解密影响效率
- CA认证费用高昂


#### http版本问题 

##### http1.x缺陷
- 客户端需要同时建立多个连接才能实现并发
- 不压缩请求和响应首部，浪费网络流量
- 不支持资源优先级，tcp利用率不高

##### http1.1新特性
- 默认长连接
- 支持流水线方式
- 支持同时打开多个tcp连接
- 新增缓存处理指令cache-control max-age 
- 支持虚拟主机
- 新增状态码 100
- 支持分块传输编码

##### http2.0介绍
> http2.0比1.x多了什么特性，首先http2.0支持首部压缩，减少网络流量损耗，将首部字段同时存在客户端与服务端，没有修改就不携带，压缩之后的首部使用二进制帧形式，分为header帧与data帧，同一个http请求的两个帧首部具有相同的stream标识符，这样就可以实现一个tcp连接交错发送http请求与接收响应，最后只需要根据帧头标识符组装即可。
###### 二进制帧
于http1.x的文本字符消息的报文不同，http2.0将报文分为HEADERS帧和DATA帧，里面存储的是压缩过的原数据，它们都是二进制帧的形式，对于不同的帧格式他们的首部9个字节是相同的，用于标识一个帧。
在通信过程中只有一个tcp连接，但是可以同时进行多条双向数据流Stream，假定一次请求和响应为一条数据流，具有唯一数据流标识和优先级信息

这样不同数据流的帧就可以交错发送，然后根据帧头的数据流标识重新组装，这也是http2.0能实现多路复用的前提，打破了一个请求等待一个响应的相对顺序。
###### 服务端推送
浏览器在请求一个资源的时候，http2.0会将相关资源一并返回给客户端。
###### 首部压缩
- http2.0要求客户端和服务端对首部字段同时维护一个字段表，如果字段更新了就添加到首部，如果没有更新就读取本地存储的。
- http2.0使用huffman编码对首部字段进行压缩。  


### css攻击
css攻击又称为xss攻击，指的是一种代码注入攻击，分为反射型xss攻击、存储型xss攻击、dom型xss攻击。  

反射型xss:  

攻击者构造出一个特殊的包含恶意代码拼接在url后面，然后诱骗用户点击这个url，如果网站本身会回显用户输入的内容的话，那么这就是个漏洞，诱骗用户的url里面是一串js脚本，当目标网站回显的时候就会执行这段脚本，可以获得用户的敏感信息。cookie、SessionId等 。

存储型xss:  
就是将一段恶意脚本调服务端接口先存入到数据库中，其他用户如果访问到了这条数据被查询到html页面中，就有可能被执行恶意操作。比如以用户的cookie发送到攻击者制作的网站，就能获得用户的cookie。

后端对入库的特殊字符进行转义编码或者过滤。

dom型xss:  
dom型主要是恶意代码利用js操作页面的dom节点，获取用户数据。

### csrf攻击
跨站请求攻击
就是用户在持有安全网站的cookie的时候，点击了危险网站，危险网站悄悄地去访问安全网站，这时候是带上了浏览器本地地cookie的，危险网站的请求就能成功。

提前下发一个加密的Token，在访问安全网站的时候都带上这个token，或者放到header里面，访问其他网站的时候就无法获取这个token

### Ddos攻击
分布式的拒绝服务攻击。  
就是拒绝服务攻击，占着茅坑不拉屎。

但是由于ip地址各不相同，且短时间大量不同的ip同时请求

- 限流
- ip黑名单
- 带宽扩容
    - 增加服务器数量，提高请求处理能力，流量分发到不同服务器
- CDN网络，就近访问
    - 只有CDN服务器没有的资源才会请求

### 中间人攻击

在https中尽管数据被加密，对方身份被验证，但是东西多了，还是存在中间人攻击。

指的是https的通信双方，还存在一个中间人，中间人给https两端传输 从加密到数据通信 的全过程。

这里面可以找出的漏洞在证书。

1、如果一个证书没有被CA机构认证，就可以做成一个中间人。
2、某些应用可以在浏览器本地埋一些证书，导致我不再向CA机构认证证书的身份。

