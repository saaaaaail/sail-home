---
title: jvm知识点复习
date: 2020-04-21 17:36:24
tags:
- jvm
- java
categories:
- java
---

# 一、知识点
## jvm内存模型
- 程序计数器
- 虚拟机栈
- 本地方法栈
- 堆区
- 方法区
- 运行时常量池

### 程序计数器
线程私有，如果正在执行的方法是java方法，则记录的是字节码指令的地址，如果正在执行的方法是native方法，则记录为空。不会报栈溢出、内存溢出异常。
### 虚拟机栈
线程私有，保存局部变量表、操作数栈、方法出口、动态链接等。栈深度大于虚拟机允许的最大深度，那么会报栈溢出异常。如果虚拟机栈内存不够，且无法申请到新的内存，那么会报内存溢出异常。
### 本地方法栈
线程私有，与虚拟机栈类似。
### 堆区
堆是jvm管理的最大一块内存，线程共享。存放对象实例。是java GC管理的主要区域。
### 方法区
用于存放已经被加载的类的信息、常量、静态变量、即使编译器编译后的代码等数据。

从jdk1.8开始，移除永久代，将方法区移到元空间，位于本地内存，而不是jvm被分配的内存。

永久代里的数据常量池和静态变量放到堆中，类的信息放到元空间里。
### 运行时常量池
运行时常量池逻辑上属于方法区，1.8版本以后放入堆区。

主要存 class文件中的常量池在被加载以后会放入这个区域 (编译期间生成的字面量和符号引用)
> 字面量: 文本字符串等   
> 符号引用: 编译原理里的概念包括(类和接口的全限定名、字段名称和描述符、方法名称和描述符)

除了编译期间生成的常量，在运行期间也可以向常量池加常量比如string.intern();

> String s1 = "Holl";   //这是一个纯字面量，(如果常量池没有"Holl",会先将"Holl"放入常量池，)返回常量池里"Holl"的引用     
> String s2 = new String("Holl");//这里(如果Holl不在常量池，先上面一步，然后)创建一个对象，从常量池中返回Holl的引用保存到对象中，s2指向这个对象，所以实际上s2指向的是Holl在常量池里的引用   
> String s3 = new String("Holl").intern();//intern方法会判断常量池有没有Holl，如果没有先在常量池放入Holl，然后直接返回Holl的引用给s3，如果常量池有Holl了，直接返回Holl的引用给s3   
> 
> 注意:  
> 这里s2，不管常量池有没有Holl返回的都是一个对象的引用，这个对象里保存的是Holl在常量池的引用。   
> 这里s3，不管常量池有没有Holl返回都是常量池中Holl的引用。  
> 当然它们做了同样的操作就是常量池不存在Holl时加入Holl到常量池。  
>
> 思考: s1与s3的最终结论是一样，为什么还存在s3这种用法?  
> 因为不是所有的字符串一开始都是字面量，对于变量来说只能使用s3的方法将引用替换成常量池的直接引用。  


## 垃圾收集

### 垃圾收集器

#### parallel Scavenge垃圾收集器
新生代垃圾收集器，多线程
其他的垃圾收集器，关注的是最短的停顿时间，而这个垃圾收集器关注吞吐量。
```
吞吐量 = 用户程序运行时间/(用户程序运行时间+垃圾收集器停顿时间)
```
按这个等式来讲，停顿时间越少，吞吐量应该越大才对，但是漏掉了一个变量，就停顿时间越少，那么触发垃圾收集会越频繁，这就非常不利于高吞吐量的程序。
因此为了高吞吐量，停顿时间不能过短也不能过长，寻找一个最优值。

#### CMS

#### G1

## 对象内存布局

## 类加载

### 类加载器

### 自定义类加载器
findClass()方法是直接进行使用当前定义类进行加载
defineClass()将二进制文件转化为Class对象
loadClass()会先进行父加载器查找，没找到才会调用findClass()

其中findClass与loadClass可以自定义，区别自己悟

### tomcat类加载
tomcat类加载器的话是违背了双亲委派原则的，首先执行完启动类加载器，以及扩展类加载器以后，执行systemClassLoader加载tomcat启动的类在bin目录下面，

然后下面就是Tomcat的通用类加载器（包括catalinaLoader与sharedLoader，加载的类位于/lib目录下），以及web应用程序类加载器（加载WEB-INF目录下的classes目录以及lib目录）。

在加载完启动类加载器、扩展类加载器、系统类加载器以后会优先执行各个Web应用的类加载器。

# 二、问题