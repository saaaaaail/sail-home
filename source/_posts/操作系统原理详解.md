---
title: 操作系统原理详解
date: 2020-07-02 20:40:59
tags:
- 操作系统
- linux
---

# linux操作系统原理详解
最近要系统性的复习操作系统准备面试，决定结合linux来一起看看操作系统原理。参考《深入理解Linux内核(第三版)》

## 进程管理
进程被定义为程序执行时的一个实例。
### **进程描述符**  
进程描述符为进程控制块PCB，与进程一一对应，由进程描述符指针指向，在Linux中定义为task_struct类型的结构，描述进程的基本信息和运行状态。

进程描述符和进程的内核态堆栈存放在一个单独的8kb内存区中。esp寄存器指针指向栈顶。这俩东西配对存储，使得很容易通过esp指针获得进程描述符的指针。
这俩东西的起始地址方向相反，进程描述符指针+8k就得到了内核栈的栈顶指针。
> linux内核2.4中的定义 
```c
union task_union {
      struct task_struct task;
      unsigned long stack[INIT_TASK_SIZE/sizeof(long)];
};
```
> 内核堆栈与task_struct分配在一个8kb的物理块，内核堆栈约占7kb，栈顶位于高位地址，然后由高地址向低地址扩展，当内核栈栈顶指针到达task_struct时会发生栈溢出，task位于8kb物理块的低位地址约占1kb大小

**PCB通常包含的内容**:  
|进程描述信息|进程控制和管理信息|资源分配清单|处理机相关信息|
|-|-|-|-|
|进程标识符(PID)|进程当前状态|代码段指针|通用寄存器值|
|用户标识符(UID)|进程优先级|数据段指针|地址寄存器值|
||代码运行入口地址|堆栈段指针|控制寄存器值|
||程序的外存地址|文件描述符|标志寄存器值|
||进入内存时间|键盘|状态字|
||处理机占用时间|鼠标||	 
||信号量使用|||	 	 

#### **进程的堆栈**

每个进程都有自己的堆栈，内核在创建一个新的进程时，在创建进程控制块task_struct的同时，也为进程创建自己堆栈。一个进程有2个堆栈，用户堆栈和内核堆栈；用户堆栈的空间指向用户地址空间，内核堆栈的空间指向内核地址空间。当进程在用户态运行时，CPU堆栈指针寄存器指向的用户堆栈地址，使用用户堆栈，当进程运行在内核态时，CPU堆栈指针寄存器指向的是内核栈空间地址，使用的是内核栈；

### **进程状态**  
在操作系统概念中的状态为：  
可运行状态、阻塞状态、终止状态

在linux中的状态：   
**可运行状态**:要么占用CPU执行，要么准备执行。  
**可中断的等待状态**:进程被挂起，直到一个条件，一个信号传递过来唤醒进程。  
**不可中断的等待状态**:进程必须等待，不能响应软中断，直到特定的事件发生。  
**暂停状态**:进程的执行被暂停，调试的时候会被暂停，资源被回收。  
**僵死状态**:进程执行结束，资源被回收除了task_struct结构，但是父进程还没有进行wait系列的系统调用返回死进程的信息。在发布wait()系统调用之前，内核不能丢弃包含在死进程描述符里的数据，父进程可能还需要他。
> 僵尸进程与孤儿进程：   
> 僵尸进程： 一个父进程利用fork创建子进程，如果子进程退出，而父进程没有利用wait 或者  waitpid 来获取子进程的状态信息，那么子进程的状态描述符依然保存在系统中。  
> 孤儿进程：一个父进程退出， 而它的一个或几个子进程仍然还在运行，那么这些子进程就会变成孤儿进程，孤儿进程将被init进程（进程号为1）所收养，并由init进程对它们完成状态收集的工作
> init进程：  
> 在内核启动阶段就会创建init进程，init进程是所有进程的父进程。

### **进程切换**
进程切换只发生在内核态
#### **进程上下文**
进程切换现场称为进程上下文(context)，包含了一个进程所具有的全部信息，一般包括：进程控制块（Process Control Block，PCB）、有关程序段和相应的数据集。

#### **用户栈切换到内核栈**
当进程由于中断或系统调用从用户态转换到内核态时，进程所使用的栈也要从用户栈切换到内核栈。系统调用实质就是通过指令产生中断，称为软中断。进程因为中断（软中断或硬件产生中断），使得CPU切换到特权工作模式，此时进程陷入内核态，进程进入内核态后，首先把用户态的堆栈地址保存在内核堆栈中（保存用户堆栈指针是为了能从内核态切换回来的时候恢复现场），然后设置CPU堆栈指针寄存器的地址为内核栈地址，这样就完成了用户栈向内核栈的切换。

> 进入内核态以后回来的时候能知道用户栈栈顶指针的位置，那么当进入内核态的时候如何知道的内核态堆栈指针的位置了，根据进程描述符的指针就可以算出内核态堆栈栈顶指针的位置，因为进程控制块与内核堆栈分配在一个连续的8kb空间里面。

#### **进程切换**
进程切换发生在内核态，这时候即将切换的进程已经陷入到了内核态。

当一个进程的时间片用完，经过线程调度以后要切换为其他进程，首先要保存线场当前进程的cpu里的寄存器的值都入栈，然后将进程的页表切换为目标进程的页表，然后切换内核堆栈与硬件上下文。

1. 调用switch_mm()函数进行进程页表的切换；
2. 调用 switch_to() 函数进行 CPU寄存器切换；

#### 硬中断与软中断
硬中断通常是由外部设备所产生的，通过中断线的电信号到达中断控制器，由中断控制器将中断号发给cpu，然后cpu去确定中断处理程序入口地址，置为PC，然后cpu执行。硬中断的特定就是响应迅速，处理快。

软中断通常是由运行着的进程所产生的中断。通过特定的指令产生中断，而且软中断的中断号是自己指定的，然后cpu去执行，而且常常是使用内核代码处理硬中断未完成的工作 ，属于中断的下半部。

### **进程创建**
在linux系统中，系统启动以后第一个进程由系统来创建，其余进程都必须由已存在的进程来创建，创建一个子进程的系统调用为fork()，我们都知道一个进程的数据包含BSS段（存未初始化的全局变量）、数据段（存初始化后的全局变量）、代码段（存放程序代码）、堆（存放malloc动态分配的内存）、栈（存局部变量）五部分，fork()创建进程会复制父进程的这些数据结构，但是不是与父进程共享而是单独分配的内存，fork在linux中使用的写时复制技术，刚开始是共享父进程数据段，在写数据段时才会进行复制。


### **内核线程**
内核经常需要在后台执行一些耗时操作，就通过内核线程来实现，只在内核态运行，也没有独立的地址空间

### **撤销进程**
进程终止的一般方式为调用exit()系统调用。

### **进程调度**
进程调度的过程就是选择哪个进程去占用cpu执行。

进程调度通过不同的进程调度算法来决定如何调度。   

> linux中动态优先级数值越小，动态优先级越高。

linux调度策略是基于优先级排队的，每个进程都与一个值关联，这个优先级是动态的，对于长时间没有使用CPU的的进程动态提升他们的优先级（提升优先级通过降低优先级数值，对于已经占用CPU很长时间的进程动态减少优先级来处罚。

一般将进程区分为三类:  
#### **交互式进程**:
进程经常与用户交互，需要花时间等待用户操作，当输入被接受时，必须很快唤醒进程。
##### 时间片轮转
将所有的就绪的进程按照FCFS的顺序排成一个队列，每次调度把CPU时间分给队首进程，该进程可以执行他获得的时间片，时间片用完了就触发定时中断，挂起该进程并排到队尾，继续给此时对头的进程分配时间片。
- 时间片轮转的效率与一次分配的时间片有关系，太短了导致进程切换频繁，CPU利用率低，太长了就没有实时性了。
##### 动态优先级调度
类似于动态时间片轮转。  
为每个进程分配一个优先级，按进程优先级进行调度，而且会动态修改进程的优先级。

linux采用的此种方式进行优先级调度。会给每个进程都分配两种优先级。
- **静态优先级** 这种优先级由用户赋给实时进程，范围由1到99，越小优先级越高，调度程序不会改变他。
- **动态优先级** 这种优先级只用于普通进程，实质上它是基本时间片与当前时期内剩余时间片之和。

linux进行调度需要的数据结构都记录在进程描述符中，包括以下几个域，简单记录下：
- need_reached 由ret_from_intr()检查的一个标志，决定是否调用schedule()函数
- policy 调度的类型，可选值如下:
  - SCHED_FIFO 先入先出的实时进程
  - SCHED_RR 循环轮转的实时进程
  - SCHED_OTHER 普通的分时进程
  - SCHED_YIELD 当进程调用sched_yield()系统调用时，这个标志被设置。调度程序就把进程描述符放在运行队列的尾端。当内核在执行一个较长且不紧急的任务时，又希望给其他进程机会，就会设置这个标志，并调用schedule()
- rt_priority 实时进程的静态优先级 普通进程用不到
- priority 进程的基本时间片 又称为基本优先级
- counter 当前时间片用完之前剩余的CPU时间节拍 在update_process_times()函数每个节拍都会将当前进程的counter-1
  
以上参数中，priority与counter对于普通进程而言决定了进程的分时与动态优先级，对于SCHED_RR实时进程只用来分时，对于SCHED_FIFO实时进程用不到。

##### 多级反馈队列
一个进程需要执行100个时间片，如果采用时间片轮转，那么需要交换100次。

多级队列为这种需要连续执行多个时间片的进程考虑，里面设置了多个队列，每个队列对应了线程能执行的时间片的长短，例如分为1、2、4、8...等时间片，第一个队列入cpu执行，如果没执行完会进入第二个时间片长一点的队列，依次类推。

最上面的时间片最短的优先级最高，只有上一个队列没有进程在排队，才会执行后面的队列。

#### **批处理进程**:
经常后台运行，不必有很快的响应,保证吞吐量和周转时间。
##### 先来先服务 FCFS
非抢占式的调度算法，有利于长作业，但不利于短作业，短作业必须长时间等待前面的长作业执行完。
##### 短作业优先 SJF
非抢占式的调度算法，保证运行时间短的作业优先运行，一直有短作业到来的话，有可能使长作业饿死。
##### 最短剩余时间优先 SRTN
短作业优先的抢占式算法，按剩余运行时间的顺序进行调度，当新的作业到来，其整个运行时间比当前进程剩余时间要短，则挂起当前进程，运行新来的进程。
#### **实时进程**:
有很强大的调度需要，绝不会被低优先级进程阻塞，必须要有很短的响应时间。    
实时系统分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

### **进程同步**

#### 临界区
对临界资源(临界资源指的是一次仅允许一个进程使用的资源，硬件如打印机、磁带机，软件如消息队列、变量、缓冲区等)进行访问的代码被称为临界区，为了能正常安全地访问临界区资源，每个进程进入临界区之前要进行检查。

#### 同步与互斥
**同步** :同步指多个进程合作完成某个任务，但是这些进程之间有先后顺序的要求，必须按照一定的先后顺序执行。
**互斥** :多个进程同一时刻只能有一个进程进入临界区。

#### 信号量
信号量是一个整型变量，可以对其进行down与up操作，也就是PV操作

down，如果信号量大于0，执行-1操作；如果信号量等于0，进程睡眠，等待信号量大于0并且被唤醒。

up，对信号量执行+1操作，并且唤醒睡眠的进程让其完成down操作。

以上两个操作必须是原语，在linux中通常会提前关中断，执行完以后开中断

#### 管程
由于信号量的机制，PV操作成对出现，但是位置分散，而且使用不当会造成死锁，因此提出了管程的机制。
管程的特点就是某个时刻只能有一个进程/线程使用管程。而且在不满足某个条件变量的时候能自我阻塞退出管程等待唤醒，等待其他进程/线程获得管程执行后唤醒其他进程/线程。

>所以在java中synchronized关键与Lock锁都实现了类似管程的功能。  
简单记录下synchronized的管程理解。  
**监视者对象**:Monitor Object负责公共的接口方法，java中的Object就是监视者对象。  
**同步块**:在获得了监视者对象以后，才能执行这块代码，保证了同一时刻只有一个线程执行。  
**监视锁**:Monitor Lock 每个监视者对象都会有一把监视锁。
**监控条件**:Monitor Condition 根据是否获得锁以及是否满足监控条件来决定阻塞还是唤醒进程/线程

#### 同步问题的sail实现
##### 生产者消费组队列
##### 哲学家就餐问题
##### 读者-写者问题

### **进程通信**

为了能达到进程同步的目的，需要让进程间进行通信，传输一些同步必须的数据。

#### 管道
管道是一个固定大小的缓冲区，只支持半双工通信，只能在父子进程和兄弟进程间使用。

可以c++里面通过调用pipe函数创建，fd[0]用于读，fd[1]用于写。
```c++
#include <unistd.h>
int pipe(int fd[2]);
```
#### 命名管道
与管道相同，只是去除了只能父子进程、兄弟进程通信的限制。

借助c++的mkfifo函数来创建。管道实际是一个file结构和一个VFS索引，也就是一个虚拟的文件。常用于客户进程与服务端进程间的通信，客户进程写完了以后，服务进程去读，服务进程写完了以后，客户进程去读。
```c++
#include <sys/stat.h>
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);
```

#### 信号signal
信号具有平台相关性，不同平台下能使用的信号种类不同也十分有限，**用于通知进程某事件的发生**。

#### 消息队列
消息队列独立于进程存在，不需要进程维护管理。
消息队列提供了同步阻塞的方法，不许进程自己提供。
读进程能有选择地接收不同类型的消息。

#### 信号量
是一个计数器，也能称为互斥量，能控制进程同步的访问共享资源。

#### 共享内存
允许多个进程共享一片存储区域，因为数据不需要在进程间复制效率很高，但是对共享数据访问的话要使用使用同步机制保证数据安全。

#### 套接字
指定ip与端口能实现相同机器或者不同机器间的通信。

<!-- ## 操作系统的死锁问题
### 发生死锁的必要条件
根据死锁可以推出以下四种情况：
- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
- 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
- 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

### 处理方法

#### 死锁检测与恢复


#### 死锁预防
#### 死锁避免 -->
### 死锁问题
死锁的概念：在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。

通俗地讲，就是两个或多个进程互相持有资源并且等待对方持有的资源，每个进程都不愿意放弃自己的资源，导致没有进程可以继续执行。  

（1）系统资源不足；（2）进程推进顺序非法。

　　产生死锁的必要条件：

　　（1）互斥（mutualexclusion），一个资源每次只能被一个进程使用；

　　（2）不可抢占（nopreemption），进程已获得的资源，在未使用完之前，不能强行剥夺；

　　（3）占有并等待（hold andwait），一个进程因请求资源而阻塞时，对已获得的资源保持不放；

　　（4）环形等待（circularwait），若干进程之间形成一种首尾相接的循环等待资源关系。

　　这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

　　死锁的解除与预防：理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源 的分配要给予合理的规划。

#### 死锁的处理策略：
##### 鸵鸟策略
等待死锁发生以后再去解决

##### 预防策略
破坏4个必要条件中的一个，就不会发生死锁
- 互斥条件不能被破坏，如果资源共享可以破坏，问题是资源不能共享，如果共享会造成数据不一致的问题。
- 破坏其他三个都可以

##### 避免策略
避免死锁是尽量不破坏四个必要条件，在运行过程中来避免死锁发生。
、检测与恢复策略。
##### 银行家算法
通过有效分配资源来避免死锁

##### 常用避免死锁的方法
 - 顺序加锁
  
 - 加锁限时
     - 一段时间没获取到资源就放弃获取锁，同时释放自己的资源
 - 解除死锁
     - 指一旦检测到死锁就剥夺某个进程占用的资源或者让进程回退


## 内存管理
### 虚拟内存
虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用空间。

操作系统将内存抽象为地址空间。每个程序拥有自己的地址空间，地址空间被分割成多个块，每一块被称为一页，这些页在使用的时候会被映射到实际的物理内存（可以不连续），不需要所有页都必须在物理内存中，如果使用到一页不在物理内存中，则会引发缺页异常，由硬件重新分配缺失的物理内存，并重新执行。

因此，虚拟内存技术保证了程序运行时不需要将虚拟地址每一页都映射到物理内存，仅仅只是用多少映射多少，所以使得有限的物理内存运行大程序成为可能。

### 分页系统地址映射
内存管理单元（MMU）管理着虚拟地址（线性地址）和物理内存的转换，其中页表（Page table）存储着页（虚拟地址空间）和页框（物理内存地址）的映射关系。
>对于linux而言，内存映射主要靠的页式内存管理机制，页机制是现代CPU都具备的，而段式内存管理是intel86系统架构独有的概念。linux中为了保证兼顾intel86平台先分段再分页的规则，使虚拟地址具有了相同的段基址 【0(段基址):偏移量(通过段基址+段内偏移量得到的是线性地址)】（这个 段基址:偏移量 的地址组合出现在段式内存管理里面，称为逻辑地址），所以实际上linux中的逻辑地址与线性地址是一致的。

了解了各个地址的关系以后，研究一下页式管理的虚拟地址的构成。

一个虚拟地址可以区分两块:页面号和页面内偏移量。
对于一个32位linux系统，其页框大小为4kb，那么使用2^12表示偏移量即可全部寻址，高位的20位均可以表示页面号，根据操作系统书本的描述，页面号乘以页表项的长度加上页表的起始地址即可获得页表项在页表中的位置，根据这个位置号能获得物理块号的地址。将物理块号作为高位，将页面内偏移作为低位完成拼接即可获得页框的物理地址。

### 页面置换算法
因为内存大小有限，访问的页面可能不在内存中，这时候发生缺页中断而将这一页从磁盘中调入内存。如果页面已经满了，那就必须从内存里选一个页面出来保存新的数据。

#### 最长时间内不再被访问 OPT
理论上的最优算法，所换出的页面是最长时间内不再被访问，但是因为无法知道一个页面的多长时间内不会再被访问。可以保证最低的缺页率。

#### 最久未使用LRU
无法知道未来使用内存的情况，但是可以根据过去使用内存的情况来替换，最久没有使用过的页面可以替换掉。

#### 最近未使用NRU
每个页面有两个状态:R与M ，当页面被访问时设置R=1，当页面被修改时设置M=1，R会定时被清零。  
将页面分为以下四类:
- R=0,M=0
- R=0,M=1
- R=1,M=0
- R=1,M=1
NRU 优先替换出已经被修改的脏页面（R=0,M=1），而不是频繁访问的干净页面（R=1,M=0）。

#### 先进先出FIFO
无法保证页面的命中率，随缘。

#### 第二次机会算法
将页面构造成一个FIFO队列，每个页面有一个标志位R，被访问或者被修改的将R=1,队列满的时候判断即将出队的页面R如果等于0，就直接让他出队，如果R==1，则将R置为0并把这个页面重新入队。

#### 时钟
第二次机会算法需要在队列中移动页面，影响效率。时钟算法不用移动页面节点，将页面构建成一个环，用一个指针指向最先入队的节点。

### 分段
为了解决 内存地址空间不隔离，内存地址不固定 这俩问题，引入了分段的概念.
首先，分段在程序编译期间会建立多个表。
>在编译过程中会建立许多的表，来确定代码和变量的虚拟地址：  
1.被保存起来供打印清单的源程序正文；  
2.符号表，包含变量的名字和属性；  
3.包含所有用到的整形和浮点型数据的表；  
4.语法分析树，包括程序语法分析的结果；  
5.编译器内部过程调用的堆栈。  

前四个表在编译期会动态增长，如果使用分页地址就会被覆盖。  
这多张表分成逻辑上的多个段，逻辑上连续的地址空间。   

如果仅仅使用分段机制管理内存，那么这一张段表就对应一块连续的物理内存地址，逻辑地址的构成是段基址+段内偏移地址，根据段基址计算再到段表去查询获得物理地址的基址加上偏移地址就获得了实际的物理地址。但是在段式管理下，由于分配的内存不是定长的，时间长了，就会碎片化，导致有足够的内存空间但是无法分配给某个进程。

### 段页式
首先，分页与分段都是为了更好的使用内存资源。

段页式就解决了 内存地址空间不隔离，内存地址不固定，内存使用率不高 这仨问题。
首先段式管理解决了上面俩问题。

在段页式机制下面，程序内存地址被分成了多个连续的地址空间的段，在段内又分成了地址空间大小一致一般为4kb的页，解决了地址空间连续，利用率不高的问题。
段页式机制下，由段表计算出来的地址被称为线性地址，也就是分页里面的虚拟地址，将这个地址进行拆分，前一部分表示页面号，后一部分表示页面内偏移地址，页面号经过计算到页表中查询获得页的起始地址，加上页面内偏移就能计算得到实际的物理地址。

### 分页与分段的比较
对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。

地址空间的维度：分页是一维地址空间，分段是二维的。

大小是否可以改变：页的大小不可变，段的大小可以动态改变。

出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

### 2020/8/22 面试>谈一谈分段与分页
分段与分页的目的都是为了更好的利用内存资源。
分段指的是用户进程将自己的内存划分为多个逻辑段，每个段有自己的段号，段内物理地址连续，段间物理地址不连续，通过段表来记录逻辑地址到物理地址的映射关系，（取出逻辑地址的前几位为段号，后几位为段内偏移量，通过段表项起始地址+段号乘以段表项的长度，得到段号对应段表项的地址，然后取出对应段表项的起始物理地址，将起始物理地址+段内偏移量得到物理地址）段式内存管理解决了内存地址不隔离的问题，而且有段表也解决了直接使用物理地址，地址不固定的问题。
分页指的是将内存空间划分为固定大小的内存块，32位linux为4kb大小，每个块称为一页，通过页表可以不连续的映射物理内存块，每个页表项就是一个4kb物理内存块的起始地址（通过虚拟地址），并且每块大小相同也不会产生内存碎片。如果仅仅只是分页不分段的话，那内存空间是不隔离的，然后在分页中还有虚拟地址技术，可以分配一段连续的虚拟地址空间但是不映射物理页，当使用到对应的虚拟地址页时，发现缺页的时候才发生中断去分配物理内存页。这种技术可以运行大内存程序。

## 磁盘管理


### 磁盘性能参数
寻道时间：磁头定位到磁道所需要的时间

旋转延迟：磁道定位之后，磁盘控制器开始等待，直到适当的扇区旋转到磁头处的时间。

存取时间：寻道时间+旋转延迟，即达到读或写的位置所需要的时间。

传输时间：磁头定位完成，磁头通过下面旋转的扇区，执行读操作或写操作所需要的时间。

### 磁盘调度

[四种磁头调度算法](https://www.cnblogs.com/tjulym/p/5003655.html)



## linux常用指令

### chmod 命令
示例:chmod ugoa+rwx directory1   
设置目录的所有人(u)、群组(g)以及其他人(o)以读（r，4 ）、写(w，2)和执行(x，1)的权限 chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限

### jps命令
jps是jdk提供的一个查看当前java进程的小工具。  
jps -l 输出完整的包名
jps -v 输出jvm的参数

### ps命令
ps -aux 查看系统所有进程的数据
能看到PID进程id、CPU进程占用的cpu、MEM进程占用的物理内存百分比、VSZ进程用掉的虚拟内存、RSS进程占用的固定内存量。

STAT：该程序目前的状态，主要的状态有：
- R ：该程序目前正在运作，或者是可被运作；
- S ：该程序目前正在睡眠当中 (可说是 idle 状态啦！)，但可被某些讯号(signal) 唤醒。
- T ：该程序目前正在侦测或者是停止了；
- Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态

### top命令
1. 第一行参数

|内容|含义|
|-|-|
|05:43:27|表示当前时间|
|up 4:52|系统运行时间 格式为时：分|
|2 users|当前登录用户数|
|load average: 0.58, 0.41, 0.30	|系统负载，即任务队列的平均长度。 三个数值分别为 过去1分钟、5分钟、15分钟前到现在的平均值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。 |
> load average 平均负载可以通过uptime或者top查看，如果三个值依次减小，说明系统负载是上升的趋势，通过mpstat查看哪个进程在占用cpu，是使用cpu比较高还是io等待时间比较高。

2. 第二行参数 Tasks: 159 total, 1 running, 158 sleeping, 0 stopped, 0 zombie   
表示进程的数量

3. 第三行参数 %Cpu(s): 37.0 us, 3.7 sy, 0.0 ni, 59.3 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st  
表示cpu的信息。 mpstat指令也可单独查看


|内容|含义|
|-|-|
|37.0 us|用户空间占用CPU百分比|
|3.7 sy|内核空间占用CPU百分比|
|0.0 ni|用户进程空间内改变过优先级的进程占用CPU百分比|
|59.3 id|空闲CPU百分比|
|0.0 wa|等待输入输出的CPU时间百分比|
|0.0 hi|硬中断（Hardware IRQ）占用CPU的百分比|
|0.0 si|软中断（Software Interrupts）占用CPU的百分比|

4. 第四行参数 KiB Mem: 1530752 total, 1481968 used, 48784 free, 70988 buffers   
5. 第五行参数 KiB Swap: 3905532 total, 267544 used, 3637988 free. 617312 cached Mem  

|内容|含义|
|-|-|
|KiB Mem: 1530752 total|物理内存总量|
|1481968 used|使用的物理内存总量|
|48784 free|空闲内存总量|
|70988 buffers（buff/cache）|用作内核缓存的内存量|
|KiB Swap: 3905532 total	|交换区总量|
|267544 used	|使用的交换区总量|
|3637988 free	|空闲交换区总量
|617312 cached Mem	|缓冲的交换区总量。
|3156100 avail Mem	|代表可用于进程下一次分配的物理内存数量

ps：  
cat /proc/meminfo 指令查看详细的内存使用情况  
vmstat 指令 也可查看内存占用情况

top指令 查看进程的参数  
    PID：进程的ID
　　USER：进程所有者
　　PR：进程的优先级别，越小越优先被执行
　　NInice：值
　　VIRT：进程占用的虚拟内存
　　RES：进程占用的物理内存
　　SHR：进程使用的共享内存
　　S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数
　　%CPU：进程占用CPU的使用率
　　%MEM：进程使用的物理内存和总内存的百分比
　　TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。
　　COMMAND：进程启动命令名称

> [top命令](https://blog.csdn.net/yjclsx/article/details/81508455)

# netstat
netstat -apt 查询所有状态的端口（已连接或者监听），并打印进程的pid与进程名

## linux问题

### linux中的cached与buffers
buffer缓冲区常常是用来将空闲的内存分配出来给块设备做读写缓冲区用的，用来暂存数据
cached是作为读取文件系统的cache，读写文件的时候为了提高效率，将文件在内存中进行缓存。

### linux中的虚拟内存与与swap空间
虚拟内存指的就是linux使用的不存在的空间，这一部分空间物理内存肯定是给不了了，因此linux通过两种方法来进行内存管理，一种是调页算法，即页面替换算法，将容易命中的数据放到物理内存中，还有一种就是交换，即将没有足够空间的进程整个放到磁盘上。